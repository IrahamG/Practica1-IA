/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package com.mycompany.iatesting;

import java.util.ArrayList;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author Iraha
 */
public class agentGUI extends javax.swing.JFrame {

    public static int[][] field = new int[5][5];
    // CREACIÓN DEL AGENTE DE NOMBRE AVELINE
    public static Agent aveline = new Agent();
     
    // CREACIÓN DEL ENEMIGO LLAMADO ERINA
    /*
    Se generan dos números al azar entre 0 y 4 que serán las coordenadas
    de inicio
    */
        
    public static int eCorX = (int)Math.floor(Math.random()*(4-0+1)+0);
    public static int eCorY = (int)Math.floor(Math.random()*(4-0+1)+0);
    public static Enemy erina = new Enemy(eCorX, eCorY);
        
    // CREACIÓN DEL TESORO
        
    public static int tCorX = (int)Math.floor(Math.random()*(4-0+1)+0);
    public static int tCorY = (int)Math.floor(Math.random()*(4-0+1)+0);
    public static Treasure tesoro = new Treasure(tCorX, tCorY);
        
    // CREACIÓN DE LOS POZOS
    // Creación del pozo 1
    public static int p1CorX = (int)Math.floor(Math.random()*(4-0+1)+0);
    public static int p1CorY = (int)Math.floor(Math.random()*(4-0+1)+0);
        
    public static Pit pozo1 = new Pit(p1CorX, p1CorY);
        
    // Creación del pozo 2
    public static int p2CorX = (int)Math.floor(Math.random()*(4-0+1)+0);
    public static int p2CorY = (int)Math.floor(Math.random()*(4-0+1)+0);
        
    public static Pit pozo2 = new Pit(p2CorX, p2CorY);
    
    /**
     * Creates new form agentGUI
     */
    public agentGUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jButton1 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea3 = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(10);
        jTextArea1.setFont(new java.awt.Font("Segoe UI", 0, 24)); // NOI18N
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        jTextArea2.setEditable(false);
        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jScrollPane2.setViewportView(jTextArea2);

        jButton1.setText("INICIO");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel1.setFont(new java.awt.Font("Microsoft Tai Le", 0, 18)); // NOI18N
        jLabel1.setText("SIMBOLOGIA");

        jLabel2.setText("1 - Agente");

        jLabel3.setText("2 - Enemigo");

        jLabel4.setText("3 - Pozo");

        jLabel5.setText("4 - Tesoro");

        jLabel6.setText("5 - Casilla visitada previamente");

        jLabel7.setFont(new java.awt.Font("Microsoft Tai Le", 0, 18)); // NOI18N
        jLabel7.setText("GUÍA DE USO");

        jTextArea3.setEditable(false);
        jTextArea3.setColumns(20);
        jTextArea3.setRows(5);
        jTextArea3.setText("Al dar clic en \"Inicio\" se cargaran todos los\nturnos de esta iteración y son impresos en \npantalla tras unos segundos.\nEn el area de abajo se imprime el resultado, \nmientras que en la consola se imprime lo\nque va sucediendo al momento de cada turno\n\nAveline = Agente\nErina = Enemigo");
        jScrollPane3.setViewportView(jTextArea3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(65, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3)
                    .addComponent(jLabel2)
                    .addComponent(jLabel4)
                    .addComponent(jLabel5)
                    .addComponent(jLabel6)
                    .addComponent(jLabel1)
                    .addComponent(jLabel7)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 276, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(40, 40, 40)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton1)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 299, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 299, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(93, 93, 93))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 287, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel6)
                        .addGap(38, 38, 38)
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jScrollPane3)))
                .addGap(18, 18, 18)
                .addComponent(jButton1)
                .addContainerGap(50, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    //ACCIÓN DEL BOTÓN DE INICIO
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed

        
        int turnos = 0;
        int turno = 0;
        ArrayList<int[]> casillasProhibidas = new ArrayList<int[]>();
            
        //BUCLE PRINCIPAL DEL JUEGO
        while(true) { 
                  
            //LLENADO DEL CAMPO EN LA INTERFAZ GRÁFICA
            jTextArea1.append("Turno: " + String.valueOf(turno));
            jTextArea1.append("\n");
            for (int i = 0; i < field.length; i++) {
                for (int j = 0; j < field.length; j++) {
                    jTextArea1.append("[" + field[i][j] + "]");
                }
                jTextArea1.append("\n");
            }
            jTextArea1.append("\n");
            
            if (aveline.getStatus() == 2) {
                    break;
                }

                //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                //~~~~~~ TURNO DE AVELINE ~~~~~~~~~~~
                //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


                if(turnos != 3) {
                    int[] coordenadasProhibidas = new int[2];

                    //~~~~~~~~~~~~~~~~~~~~~ESCANEAR CASILLAS ADYACENTES~~~~~~~~~~~~~~~~~~~~~~~~~
                    // Matriz para almacenar los datos de las casillas adyacentes: valor y coordenadas
                    int[][] data = new int[8][3];

                    //Almacenando las coordenadas actuales de Aveline
                    int currentX = aveline.getCorX();
                    int currentY = aveline.getCorY();

                    /*Coordenadas auxiliares
                    Las auxiliares 1: Empiezan en la esquina inferior derecha
                    Las auxiliares 2: Empiezan en la esquina superior izquierda
                    */
                    int auxX = currentX + 1;
                    int auxY = currentY + 1;

                    int aux2X = currentX - 1;
                    int aux2Y = currentY - 1;

                    // Variable auxiliar para el arreglo de datos
                    int dataAux = 0;



                    //Coordenadas auxiliares (posición en la esquina superior izquiera de Aveline)

                    //~~~~~~Bucles para almacenar las casillas en un arreglo.~~~~~
                    /*
                    El bucle inicia en la esquina inferior derecha y continua hacia arriba.
                    Si las coordenadas no existen en el area de juego no se almacena en el arreglo
                    Si las coordenadas se encuentran se guarda en el arreglo un arreglo de la siguiente manera:
                    [valor, X, Y]
                    */
                    for (int c = 1; c < 4; c++) {
                        if (auxX <= 4 && auxX >= 0 && auxY <= 4 && auxY >= 0) {
                            if(field[auxX][auxY] == 3) {
                                coordenadasProhibidas[0] = auxX;
                                coordenadasProhibidas[1] = auxY;
                                casillasProhibidas.add(coordenadasProhibidas);
                            }
                            data[dataAux][0] = field[auxX][auxY];
                            data[dataAux][1] = auxX;
                            data[dataAux][2] = auxY;
                            dataAux++;
                        }
                        auxX--;

                    }
                    //Se reinician las coordenadas auxiliares
                    auxX = currentX + 1;
                    auxY = currentY;

                    /*
                    El bucle inicia debajo de la coordenada y continua hacia la izquierda en X
                    */
                    for (int c = 1; c < 3; c++) {
                        if (auxX <= 4 && auxX >= 0 && auxY <= 4 && auxY >= 0) {
                            if(field[auxX][auxY] == 3) {
                                coordenadasProhibidas[0] = auxX;
                                coordenadasProhibidas[1] = auxY;
                                casillasProhibidas.add(coordenadasProhibidas);
                            }
                            data[dataAux][0] = field[auxX][auxY];
                            data[dataAux][1] = auxX;
                            data[dataAux][2] = auxY;
                            dataAux++;
                        }
                        auxY--;
                    }

                    /*
                    El bucle inicia en la esquina superior izquiera y continua hacia la derecha en X
                    Utiliza las variables auxiliares 2
                    */
                    for (int c = 1; c < 3; c++) {
                        if (aux2X <= 4 && aux2X >= 0 && aux2Y <= 4 && aux2Y >= 0) {
                            if(field[aux2X][aux2Y] == 3) {
                                coordenadasProhibidas[0] = auxX;
                                coordenadasProhibidas[1] = auxY;
                                casillasProhibidas.add(coordenadasProhibidas);
                            }
                            data[dataAux][0] = field[aux2X][aux2Y];
                            data[dataAux][1] = aux2X;
                            data[dataAux][2] = aux2Y;
                            dataAux++;
                        }
                        aux2Y++;
                    }

                    aux2X = currentX;
                    aux2Y = currentY - 1;

                    for (int c = 1; c < 2; c++) {
                        if (aux2X <= 4 && aux2X >= 0 && aux2Y <= 4 && aux2Y >= 0) {
                            if(field[aux2X][aux2Y] == 3) {
                                coordenadasProhibidas[0] = auxX;
                                coordenadasProhibidas[1] = auxY;
                                casillasProhibidas.add(coordenadasProhibidas);
                            }
                            data[dataAux][0] = field[aux2X][aux2Y];
                            data[dataAux][1] = aux2X;
                            data[dataAux][2] = aux2Y;
                        }
                    }




                    //FIN DE LA ETAPA DE ESCANEO


                    //~~~~ FUNCIÓN DE MOVIMIENTO DE AVELINE ~~~~~
                    // Aveline solo puede moverse a las casillas adyacentes a la que esta
                    // Aveline no puede moverse en diagonal ni a una casilla que no este vacía
                    // Si la casilla es 0, se mueve a la casilla
                    ArrayList<int[]> movimientosPosibles = new ArrayList<int[]>();

                    //Iterar las casillas adyacentes para encontrar las casillas a las que se puede mover
                    for (int i = 0; i <= dataAux; i++) {
                            int[] movimiento = new int[2];

                                if(data[i][1] == currentX-1 && data[i][2] == currentY && field[data[i][1]][data[i][2]] != 5) {
                                    movimiento[0] = data[i][1];
                                    movimiento[1] = data[i][2];
                                    movimientosPosibles.add(movimiento);
                                } else if(data[i][1] == currentX+1 && data[i][2] == currentY && field[data[i][1]][data[i][2]] != 5) {
                                    movimiento[0] = data[i][1];
                                    movimiento[1] = data[i][2];
                                    movimientosPosibles.add(movimiento);
                                } else if(data[i][1] == currentX && data[i][2] == currentY-1 && field[data[i][1]][data[i][2]] != 5) {
                                    movimiento[0] = data[i][1];
                                    movimiento[1] = data[i][2];
                                    movimientosPosibles.add(movimiento);
                                } else if(data[i][1] == currentX && data[i][2] == currentY+1 && field[data[i][1]][data[i][2]] != 5) {
                                    movimiento[0] = data[i][1];
                                    movimiento[1] = data[i][2];
                                    movimientosPosibles.add(movimiento);
                                }

                    }

                    if(movimientosPosibles.size() == 0) {
                        System.out.println("Aveline no puede moverse");
                        break;
                    }

                    //Crear un número aleatorio para elegir un movimiento
                    Random r = new Random();
                    int random = r.nextInt(movimientosPosibles.size());


                    //Mover aveline a la casilla aleatoria
                    aveline.setCorX(movimientosPosibles.get(random)[0]);
                    aveline.setCorY(movimientosPosibles.get(random)[1]);

                    //Comprobar si Aveline se encuentra en el tesoro
                    if (aveline.getCorX() == tesoro.getCorX() && aveline.getCorY() == tesoro.getCorY()) {
                        jTextArea2.setText("Aveline ha encontrado el tesoro!");
                        aveline.setStatus(2);
                    }

                    if (aveline.getCorX() == pozo1.getCorX() && aveline.getCorY() == pozo1.getCorY()) {
                        jTextArea2.setText("Aveline ha caido en un pozo!");
                        aveline.setStatus(2);
                    }

                    if (aveline.getCorX() == pozo2.getCorX() && aveline.getCorY() == pozo2.getCorY()) {
                        jTextArea2.setText("Aveline ha caido en un pozo!");
                        aveline.setStatus(2);
                    }

                    //Hacer la posición previa de Aveline 5
                    field[currentX][currentY] = 5;

                    field[aveline.getCorX()][aveline.getCorY()] = 1;

                    //IMPRIMIR EN CONSOLA LO QUE VE EL AGENTE Y LOS MOVIMIENTOS POSIBLES
                    System.out.println("Turno: " + turno);
                    System.out.println("Turno de Aveline");
                    
                    System.out.println("Movimientos posibles: ");
                    for(int i = 0; i < dataAux; i++) {
                        System.out.println("Valor: " + data[i][0] + " X: " + data[i][1] + " Y: " + data[i][2]);
                    }
                    System.out.println("\n");

                    //Imprimir el arreglo de movimientos posibles
                    for(int i = 0; i < movimientosPosibles.size(); i++) {
                        System.out.println("X: " + movimientosPosibles.get(i)[0] + " Y: " + movimientosPosibles.get(i)[1]);
                    }
                    System.out.println("\n");
                    
                    System.out.println("Movimiento elegido: ");
                    System.out.println("Coordenada X: " + aveline.getCorX() + " Coordenada Y: " + aveline.getCorY()); 

                    turnos++;
                    turno++;
                    //FIN DEL TURNO DE AVELINE
                    
                }

                // MOVIMIENTO DE ERINA
                // Erina se mueve cada 3 turnos de Aveline
                if(turnos == 3) {
                    //~~~~~~~~~~~~~~~~~~~~~ESCANEAR CASILLAS ADYACENTES~~~~~~~~~~~~~~~~~~~~~~~~~
                    // Matriz para almacenar los datos de las casillas adyacentes: valor y coordenadas
                    int[][] data = new int[8][3];

                    //Almacenando las coordenadas actuales de Aveline
                    int currentX = erina.getCoorX();
                    int currentY = erina.getCoorY();

                    /*Coordenadas auxiliares
                    Las auxiliares 1: Empiezan en la esquina inferior derecha
                    Las auxiliares 2: Empiezan en la esquina superior izquierda
                    */
                    int auxX = currentX + 1;
                    int auxY = currentY + 1;

                    int aux2X = currentX - 1;
                    int aux2Y = currentY - 1;

                    // Variable auxiliar para el arreglo de datos
                    int dataAux = 0;

                    //Coordenadas auxiliares (posición en la esquina superior izquiera de Aveline)

                    //~~~~~~Bucles para almacenar las casillas en un arreglo.~~~~~
                    /*
                    El bucle inicia en la esquina inferior derecha y continua hacia arriba.
                    Si las coordenadas no existen en el area de juego no se almacena en el arreglo
                    Si las coordenadas se encuentran se guarda en el arreglo un arreglo de la siguiente manera:
                    [valor, X, Y]
                    */
                    for (int c = 1; c < 4; c++) {
                        if (auxX <= 4 && auxX >= 0 && auxY <= 4 && auxY >= 0) {
                            data[dataAux][0] = field[auxX][auxY];
                            data[dataAux][1] = auxX;
                            data[dataAux][2] = auxY;
                            dataAux++;
                        }
                        auxX--;

                    }
                    //Se reinician las coordenadas auxiliares
                    auxX = currentX + 1;
                    auxY = currentY;

                    /*
                    El bucle inicia debajo de la coordenada y continua hacia la izquierda en X
                    */
                    for (int c = 1; c < 3; c++) {
                        if (auxX <= 4 && auxX >= 0 && auxY <= 4 && auxY >= 0) {
                            data[dataAux][0] = field[auxX][auxY];
                            data[dataAux][1] = auxX;
                            data[dataAux][2] = auxY;
                            dataAux++;
                        }
                        auxY--;
                    }

                    /*
                    El bucle inicia en la esquina superior izquiera y continua hacia la derecha en X
                    Utiliza las variables auxiliares 2
                    */
                    for (int c = 1; c < 3; c++) {
                        if (aux2X <= 4 && aux2X >= 0 && aux2Y <= 4 && aux2Y >= 0) {
                            data[dataAux][0] = field[aux2X][aux2Y];
                            data[dataAux][1] = aux2X;
                            data[dataAux][2] = aux2Y;
                            dataAux++;
                        }
                        aux2Y++;
                    }

                    aux2X = currentX;
                    aux2Y = currentY - 1;

                    for (int c = 1; c < 2; c++) {
                        if (aux2X <= 4 && aux2X >= 0 && aux2Y <= 4 && aux2Y >= 0) {
                            data[dataAux][0] = field[aux2X][aux2Y];
                            data[dataAux][1] = aux2X;
                            data[dataAux][2] = aux2Y;
                        }
                    }


                    //~~~~~ FUNCIÓN DE MOVIMIENTO DE ERINA ~~~~~
                    //Arreglo para almacenar los movimientos posibles
                    ArrayList<int[]> movimientosPosibles = new ArrayList<int[]>();

                    for (int i = 0; i < dataAux; i++) {
                        if (data[i][0] == 0) {
                            int[] movimiento = new int[2];
                            movimiento[0] = data[i][1];
                            movimiento[1] = data[i][2];
                            movimientosPosibles.add(movimiento);
                        }
                    }

                    if(movimientosPosibles.size() == 0) {
                        System.out.println("Erina no puede moverse");
                        break;
                    }

                    //Crear un número aleatorio para elegir un movimiento
                    Random r = new Random();
                    int random = r.nextInt(movimientosPosibles.size());


                    //Mover aveline a la casilla aleatoria
                    erina.setCoorX(movimientosPosibles.get(random)[0]);
                    erina.setCoorY(movimientosPosibles.get(random)[1]);

                    //Comprobar si Erina está en la casilla de Aveline
                    if (erina.getCoorX() == aveline.getCorX() && erina.getCoorY() == aveline.getCorY()) {
                        System.out.println("Erina ha ganado");
                        break;
                    }

                    //Hacer la posición previa de Erina 0
                    field[currentX][currentY] = 0;

                    field[erina.getCoorX()][erina.getCoorY()] = 2;
                    
                    System.out.println("Turno: " + turno);
                    System.out.println("Turno de Erina");

                    for(int i = 0; i < dataAux; i++) {
                        System.out.println("Valor: " + data[i][0] + " X: " + data[i][1] + " Y: " + data[i][2]);                        
                    }
                    System.out.println("\n");
                    //Imprimir el arreglo de movimientos posibles
                    System.out.println("Movimientos posibles");
                    for(int i = 0; i < movimientosPosibles.size(); i++) {
                        System.out.println("X: " + movimientosPosibles.get(i)[0] + " Y: " + movimientosPosibles.get(i)[1]);                        
                    }
                    System.out.println("\n");
                    
                    System.out.println("Coordenada elegida:");
                    System.out.println("Coordenada X: " + erina.getCoorX() + " Coordenada Y: " + erina.getCoorY()); 

                    turnos = 0;
                    turno++;

                }

            try {    
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException ex) {
                Logger.getLogger(agentGUI.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(agentGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(agentGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(agentGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(agentGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new agentGUI().setVisible(true);
            }
        });
        
        /*
        Los elementos del campo pueden ser representados con valores
        numericos:
        1 - El agente
        2 - El enemigo
        3 - Pozo
        4 - Tesoro
        5 - Casilla previamente visitada
        Tanto los pozos como el teesoro seran estaticos y ellos y el monstruo
        serán generados al azar.
        */
        // GENERACIÓN DE CAMPO DE JUEGO Y LLENADO CON LOS VALORES
        
        
        for (int i=0; i < field.length; i++) {
            for (int j=0; j < field.length; j++) {
                field[i][j] = 0;
            }
        } 
        
        
        
        // ~~~~~~~~~~ COLOCAR ELEMENTOS EN EL TABLERO ~~~~~~~~~~
        // Colocar a Aveline
        field[aveline.getCorX()][aveline.getCorY()] = 1;

        // Colocar a Erina
        int eVal = 1; // Variable para evaluar el while
        while(eVal == 1) {
            if(field[erina.getCoorX()][erina.getCoorY()] == 0) {
                field[erina.getCoorX()][erina.getCoorY()] = 2;
                eVal = 0;
            } else {
                erina.genCor();
            }    
        }
       
        
        // Colocar el tesoro
        int tVal = 1; // Variable para evaluar el while
        while(tVal == 1) {
            if(field[tesoro.getCorX()][tesoro.getCorY()] == 0) {
                field[tesoro.getCorX()][tesoro.getCorY()] = 4;
                tVal = 0;
            } else {
                tesoro.genCor();
            }    
        }
        
        // Colocar los pozos
        // Pozo 1
        int p1Val = 1; // Variable para evaluar el while
        while(p1Val == 1) {
            if(field[pozo1.getCorX()][pozo1.getCorY()] == 0) {
                field[pozo1.getCorX()][pozo1.getCorY()] = 3;
                p1Val = 0;
            } else {
                pozo1.genCor();
            }    
        }
        
        // Pozo 2
        int p2Val = 1;
        while(p2Val == 1) {
            if(field[pozo2.getCorX()][pozo2.getCorY()] == 0) {
                field[pozo2.getCorX()][pozo2.getCorY()] = 3;
                p2Val = 0;
            } else {
                pozo2.genCor();
            }    
        }
        
        //TODO: VER POR QUE CHINGADOS NO SE IMPRIME EL MOVIMIENTO EN EL TURNO DE ERINA
       
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea3;
    // End of variables declaration//GEN-END:variables
}
